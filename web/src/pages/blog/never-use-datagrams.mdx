---
layout: "@/layouts/global.astro"
title: Never* use Datagrams
author: kixelated
description: Rethink your approach. *Unless you're doing something dope.
cover: "/blog/never-use-datagrams/bodies.jpeg"
date: 2024-02-17
---

# Never* use Datagrams

Click-bait title, but hear me out.

## TCP vs UDP
So you're reading this blog over the internet.
I would wager you do a lot of things over the internet.

If you've built an application on the internet, you've undoubtedly had to decide whether to use TCP or UDP.
Maybe you're trying to make, oh I dunno, a live video protocol or something.
There are more choices than just those two but let's pretend like we're a networking textbook from the 90s.

The common wisdom is:
* use **TCP** if you want **reliable** delivery
* use **UDP** if you want **unreliable** delivery

What the fuck does that mean?
Who *wants* unreliability?

- You don't want a hard-drive that fails 5% of writes.
- You don't want something with random holes in the middle (unless it's cheese).
- You don't want a service that is randomly unavailable because ¬Ø\\\_(„ÉÑ)\_/¬Ø.

Nobody\* wants memory corruption or deadzones or artifacts or cosmic rays.
Unreliability is a consequence, not a goal.

<figure>
	![Video glitch](/blog/never-use-datagrams/glitch.gif)
	<figcaption>
		\*Unless you're making some cursed GIF art.
		[Source](https://en.wikipedia.org/wiki/Glitch_art)
	</figcaption>
</figure>


## Properties
So what do we actually want?

Well if you go low enough level, you can use electrical impulses to do stuff like:
- Power on LEDs in a desired configuration.
- Spin magnets at ludicrous speeds.
- Make objects tingle and shake.
- etc you get the idea.

But we don't want to deal with electrical impulses.
We want higher level functionaliy.

Fortunately, software engineering is all about standing on the shoulders of others.
There are layers on top of layers on top of layers of abstraction.
Each layer provides properties so you don't have to reinvent the personal computer every time.

Our job as developers is to decide which shoulders we want to stand on.
But some of some shoulders are awful, so we have to be selective.
Over-abstraction is bad but so is under-abstraction.

What user experience are we trying to build, and how can we leverage the properties of existing layers to achieve that?

## "Unreliable"
There was a recent [MoQ interim](https://datatracker.ietf.org/wg/moq/meetings/) in Denver.
For those unaware, it's basically a meetup of masochistic super nerds who want to design a live video protocol.
We spent hours debating if we need both **FETCH** and **SUBSCRIBE** and what the hell those even mean.

<figure>
	![Denver interim](/blog/never-use-datagrams/denver.jpeg)
	<figcaption>
	I'm the one in the back right corner, the one with the stupid grin on their face.
	</figcaption>
</figure>

A few times, it was stated that **SUBSCRIBE** should be *unreliable*.
Good job, it triggered this blog post!

Like I said, nobody wants unreliability.
What we actually want is **timeliness**.
If the internet can choose between delivering two pieces of data, I want it to deliver the newest one.

In the live video scenario, this is the difference between buffering and skipping ahead.
If you're trying to have a conversation with someone on the internet, there can't be a delay.
You don't want a buffering spinner on top of their face, nor do you want to hear only what they said 5 seconds ago.

To accomplish timeliness, the live video industry often use UDP datagrams instead of TCP streams.
Likewise so does the video game industry.
But why?

## Datagrams
A datagram, aka an IP packet, is an envelope of 0s and 1s that gets sent from a source address to a destination address.
Each device has a different maximum size allowed, which is super annoying, but 1200 bytes is generally safe.
And of course, they can be silently lost or even arrive out of order.

But the physical world doesn't work in discrete packets; it's yet another layer of abstraction.
I'm not a scientist-man, but the data is converted to analog signals and sent through some medium.
It all gets serialized and deserialized and buffered and queued and retransmitted and dropped and corrupted and delayed and reordered and duplicated and lost and all sorts of other things.

So why does this abstraction exist?

## Internet of Queues
It's pretty simple actually: something's got to give.

<figure>
	![Screamer Rock](/blog/never-use-datagrams/bodies.jpeg)
	<figcaption>
		Let the packets hit the FLOOR
	</figcaption>
</figure>

When there's too much data sent over the network, the network has to decide what to do.
In theory it could drop random bits but oh lord that is a nightmare, as evidenced by over-the-air TV.
So instead, a bunch of smart people got together and decided that routers should drop at packet boundaries.

But why drop packets again?
Why can't we just queue and deliver them later?
Well yeah, that's what a lot of routers do these days since RAM is cheap.
It's a phenomenon called [bufferbloat](https://en.wikipedia.org/wiki/Bufferbloat) and my [coworkers](https://discord.com) can attest that it's my favorite thing to talk about. üê∑

But RAM is a finite resource so the packets will eventually get dropped.
Then you finally get the **unreliability** you wanted all along...

## Oh no
Oh shit I forgot, I actually want **timeliness**.
Bufferbloat is the worst possible scenario since queued packets are late packets.

So [congestion control](https://en.wikipedia.org/wiki/TCP_congestion_control) is a huge, never ending area of research.
I briefly summarized it in the [Replacing WebRTC](/blog/replacing-webrtc) post if you want more CONTENT.

But basically, the only way to avoid queuing is to detect it, and then send less.
The sender uses some feedback from the receiver to determine how long it took a packet to arrive.
That way we can infer when routers are queuing packets and back off.

<figure>
	![BBR](/blog/never-use-datagrams/bbr.png)
	<figcaption>
		[Source](https://datatracker.ietf.org/meeting/99/materials/slides-99-iccrg-iccrg-presentation-2-00.pdf):
		Riveting slides from IETF meetings that you're missing out on.
	</figcaption>
</figure>

All you need to know is that sending packets at unlimited rate is a recipe for disaster.

## You, The Application Developer
Speaking of a recipe for disaster.
Let's say you made the mistake of using UDP directly because you want them datagrams.
You're bound to mess up, and you won't even realize why.

If you want to build your own transport protocol on top of UDP, you "need" to implement:
- [retransmissions](https://www.rfc-editor.org/rfc/rfc9000.html#name-packetization-and-reliabili)
- [congestion control](https://www.rfc-editor.org/rfc/rfc9002.html#name-congestion-control)

And if you want a great protocol, you also need:
- [encryption](https://www.rfc-editor.org/rfc/rfc9001)
- [RTT estimates](https://www.rfc-editor.org/rfc/rfc9002.html#name-estimating-the-round-trip-t)
- [path validation](https://www.rfc-editor.org/rfc/rfc9000.html#name-address-validation)
- [path migration](https://www.rfc-editor.org/rfc/rfc9000.html#name-connection-migration)
- [pacing](https://www.rfc-editor.org/rfc/rfc9002.html#name-pacing)
- [flow control](https://www.rfc-editor.org/rfc/rfc9000.html#name-flow-control)
- [version negoiation](https://www.rfc-editor.org/rfc/rfc9000.html#name-version-negotiation)
- [extensions](https://www.rfc-editor.org/rfc/rfc9000.html#name-transport-parameter-encodin)
- [prioritization](https://www.rfc-editor.org/rfc/rfc9000.html#name-stream-prioritization)
- [keep-alives](https://www.rfc-editor.org/rfc/rfc9000.html#name-idle-timeout)
- [multiplexing](https://www.rfc-editor.org/rfc/rfc9000.html#name-streams)

And if you want an AMAZING protocol, you also need:
- [web support](https://developer.mozilla.org/en-US/docs/Web/API/WebTransport_API)
- [port reuse](https://www.rfc-editor.org/rfc/rfc9000.html#name-matching-packets-to-connect)
- [dynamic MTUs](https://www.rfc-editor.org/rfc/rfc9000.html#name-datagram-size)
- [multi-path](https://datatracker.ietf.org/doc/draft-ietf-quic-multipath/)
- [stateless load balancing](https://datatracker.ietf.org/doc/draft-ietf-quic-load-balancers/)
- [anycast load balancing](https://www.rfc-editor.org/rfc/rfc9000.html#section-9.6.1)

Let's be honest, you don't even know what half of those are, nor why they are worth implementing.
Just use [QUIC](https://en.wikipedia.org/wiki/QUIC).

But if you still insist on UDP instead, you're actually in good company with a lot of the video industry.
Building a live video protocol on top of UDP is all the rage; for example [WebRTC](https://webrtc.org/), [SRT](https://www.haivision.com/products/srt-secure-reliable-transport/), [Sye](https://nscreenmedia.com/amazon-buys-sye/), [RIST](https://www.rist.tv/), etc.

Unless you're Google, it's very easy make a terrible protocol on top of UDP.
Just wait for the **Replacing RTMP *but please not with SRT*** blog post.

## Timeliness
But remember, I ultimately want to achieve **timeliness**.
How can we do that with QUIC?

1. **Avoid bloating the buffers** üê∑.
Use a delay-based congestion controller like [BBR](https://www.ietf.org/archive/id/draft-cardwell-iccrg-bbr-congestion-control-01.html) that will detect queueing and back off.
There are better ways of doing this, like how WebRTC uses [transport-wide-cc](https://webrtc.googlesource.com/src/+/refs/heads/main/docs/native-code/rtp-hdrext/transport-wide-cc-02/README.md), which I'll personally make sure gets added to QUIC.

2. **Split data into streams**.
The bytes within each stream are ordered, reliable, and can be any size; it's nice and convenient.
Each stream could be a video frame, or a game update, or a chat message, or a JSON blob, or really any atomic unit.

3. **Prioritize the streams**.
Streams are independent and can arrive in any order.
But you can tell the QUIC stack to focus on delivering important streams first.
The low priority streams will be starved, and can be closed to avoid wasting bandwidth.

That's it.
That's the secret behind [Media over QUIC](https://datatracker.ietf.org/wg/moq/about/).
Now all that's left is to bikeshed the details.

And guess what?
This approach works with higher latency targets too.
If you want higher quality video at the cost of higher latency, then the fire-and-forget nature of datagrams is not what you want.

You don't need datagrams.
Use QUIC streams instead.

<figure>
	![QUIC logo](/home/quic.svg)
</figure>

## In Defense of Datagrams
But QUIC itself is implemented on top of UDP, so **Never\* use Datagrams** is a bit of a stretch.
My point is: let the smart network engineers handle the datagrams.
You should care about the actually useful properties provided by QUIC.

"But Mr. Kixelated, the latest [MoQ draft](https://www.ietf.org/archive/id/draft-ietf-moq-transport-02.html) adds support for datagrams.
You're one of the authors; are you daft?"

Yes, because you can enable FEC in OPUS and send each audio "frame" as a datagram.
But I will always contend that the audio codec is the wrong layer for FEC.
In fact, I wrote a [follow-up blog](/blog/forward-error-correction) about it if you can't get enough of my hot takes.

## Conclusion
There is no conclusion.
This is a rant.

Please don't design your application on top of datagrams.
Old protocols like [DNS](https://en.wikipedia.org/wiki/Domain_Name_System) get a pass, but be like [DNS over HTTPS](https://en.wikipedia.org/wiki/DNS_over_HTTPS) instead.

And please, please don't make yet another video protocol on top of UDP.
Get involved with [Media over QUIC](https://datatracker.ietf.org/wg/moq/about/) instead!
Join our [Discord](https://discord.gg/FCYF3p99mr) and tell me how wrong I am.

Written by [@kixelated](https://github.com/kixelated).
<img src="/blog/kixelCat.png" class="inline w-16" />
